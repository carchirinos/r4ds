# Iteración

## Introducción

En [funciones], hablamos sobre la importancia de reducir la duplicación en el código creando funciones en lugar de copiar y pegar. Reducir la duplicación de código tiene tres beneficios principales:

1. Es más fácil ver el objetivo de tu código, lo diferente llama
	más atención a la vista que aquello que permanece igual.
        
2. Es más sencillo responder a cambios en los requerimientos.  A medida que tus 
	necesidades cambian, solo necesitarás realizar cambios en un lugar, en vez
	de recordar cambiar en cada lugar donde copiaste y pegaste el código.

3. Es probable que tengas menos errores porque cada línea de código es
    utilizado en más lugares.
    
Una herramienta para reducir la duplicación de código son las funciones, que reducen dicha duplicación al identificar patrones repetidos de código y extraerlos en piezas independientes que pueden reutilizarse y actualizarse fácilmente. Otra herramienta para reducir la duplicación es la __iteración__, que te ayuda cuando necesitas hacer la misma tarea con múltiples entradas: repetir la misma operación en diferentes columnas o en diferentes conjuntos de datos.
En este capítulo aprenderás sobre dos paradigmas de iteración importantes: la programación imperativa y la programación funcional. Por el lado imperativo, tienes herramientas como bucles _for_ (del inglés _para_) y bucles _while_ (del inglés _mientras_), que son un gran lugar para comenzar porque hacen que la iteración sea muy explícita, por lo que es obvio qué está pasando. Sin embargo, los bucles _for_ son bastante detallados y requieren bastante código que se duplica para cada bucle. La programación funcional (PF) ofrece herramientas para extraer este código duplicado, por lo que cada patrón común de bucle obtiene su propia función. Una vez que domines el vocabulario de PF, podrás resolver muchos problemas comunes de iteración con menos código, más facilidad y menos errores.

### Pre requisitos

Una vez que hayas dominado los bucles _for_ proporcionados por R base, aprenderás algunas de las potentes herramientas de programación proporcionadas por __purrr__, uno de los paquetes principales de _tidyverse_.

```{r setup, message = FALSE}
library(tidyverse)
```

## Bucles _for_

Imagina que tenemos este simple _tibble_:

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

Queremos calcular la mediana de cada columna. _Podrías hacerlo_ copiando y pegando el siguiente código:

```{r}
median(df$a)
median(df$b)
median(df$c)
median(df$d)
```

Pero eso rompe nuestra regla de oro: nunca copie y pegue más de dos veces. En cambio, podríamos usar un bucle _for_:

```{r}
output <- vector("double", ncol(df))  # 1. _output_ (salida o resultado)
for (i in seq_along(df)) {            # 2. secuencia
  output[[i]] <- median(df[[i]])      # 3. cuerpo
}
output
```

Cada bucle tiene tres componentes:

1.  __output__: `output <- vector("double", length(x))`. 
    Antes de comenzar el bucle, siempre debes asignar suficiente espacio
    para la salida. Esto es muy importante para la eficiencia: si aumentas
    el bucle _for_ en cada iteración usando, por ejemplo, `c ()` , el bucle _for_
    será muy lento.
      
    Una forma general de crear un vector vacío de longitud dada es la función `vector ()`. 
	Tiene dos argumentos: el tipo de vector (_"logical"_, 
    _"integer"_, _"double"_, _"character"_, etc) y su longitud.
    
2.  La __secuencia__: `i in seq_along (df)`. Este código determina sobre qué iterar:
    cada ejecución del bucle _for_ asignará a `i` un valor diferente de
    `seq_along (df)`. Es útil pensar en `i` como un pronombre, como "eso".
    
	Es posible que no hayas visto `seq_along ()` con anterioridad. Es una versión segura de la
    familiar `1:length(l)`, con una diferencia importante: si se tiene un
    vector de longitud cero, `seq_along ()` hace lo correcto:
    
    ```{r}
    y <- vector("double", 0)
    seq_along(y)
    1:length(y)
    ```
    
    Probablemente no vas a crear un vector de longitud cero deliberadamente, pero
    es fácil crearlos accidentalmente. Si usamos `1: length (x)` en lugar
    de `seq_along (x)`, es posible que obtengamos un mensaje de error confuso.
    
3.	El __cuerpo__: `output[[i]] <- median(df[[i]])`. Este es el código que hace
	el trabajo. Se ejecuta repetidamente, con un valor diferente para `i` cada vez.
	La primera iteración ejecutará `output[[1]] <- median(df[[1]])`,
	la segunda ejecutará `output [[2]] <- median (df [[2]])`, y así sucesivamente.
	
¡Eso es todo lo que hay para el bucle _for_! Ahora es un buen momento para practicar creando algunos bucles _for_ básicos (y no tan básicos) usando los ejercicios que se encuentran a continuación. Luego avanzaremos en algunas variaciones del bucle _for_ que te ayudarán a resolver otros problemas que surgirán en la práctica.


### Ejercicios

1.  Escribir bucles _for_ para:

    1. Calcular la media de cada columna en `mtautos`.
    2. Determinar el tipo de cada columna en `vuelos`.
    3. Calcular el número de valores únicos en cada columna de `iris`.
    4. Genera 10 normales aleatorias para cada valor de $\mu = -10$, $0$, $10$ y $100$.
    
    Piensa en el resultado, la secuencia y el cuerpo __antes__ de empezar a escribir
    el bucle.

2.  Elimina el bucle _for_ en cada uno de los siguientes ejemplos tomando
     ventaja de una función existente que trabaja con vectores:
    
    ```{r, eval = FALSE}
    out <- ""
    for (x in letters) {
      out <- stringr::str_c(out, x)
    }
    
    x <- sample(100)
    sd <- 0
    for (i in seq_along(x)) {
      sd <- sd + (x[i] - mean(x)) ^ 2
    }
    sd <- sqrt(sd / (length(x) - 1))
    
    x <- runif(100)
    out <- vector("numeric", length(x))
    out[1] <- x[1]
    for (i in 2:length(x)) {
      out[i] <- out[i - 1] + x[i]
    }
    ```

3.  Combina tus habilidades para escribir funciones y bucles _for_:

    1. Escribe un bucle _for_ que imprima (_`prints()`_) la letra de la canción de niños
       "Cinco ranitas verdes".

    2. Convierte la canción infantil "10 monitos saltaban en la cama" en una función. Generalizar
       a cualquier cantidad de monitos en cualquier estructura para dormir.

    3. Convierte la canción "99 botellas de cerveza en la pared" en una función.
       Generalizar a cualquier cantidad, de cualquier tipo de recipiente que contenga 
       cualquier líquido sobre cualquier superficie.

4.  It's common to see for loops that don't preallocate the output and instead
    increase the length of a vector at each step:
    Es común ver bucles _for_ que no preasignan la salida y en su lugar
    aumentan la longitud de un vector en cada paso:
     
    ```{r, eval = FALSE}
    output <- vector("integer", 0)
    for (i in seq_along(x)) {
      output <- c(output, lengths(x[[i]]))
    }
    output
    ```
    
    ¿Cómo afecta esto el rendimiento? Diseña y ejecuta un experimento.

## Variaciones de bucles _for_

Una vez que tienes el bucle _for_ básico bajo tu cinturón, hay algunas variaciones que debes tener en cuenta. Estas variaciones son importantes independientemente de cómo hagas la iteración, así que no te olvides de ellas una vez que hayas dominado las técnicas de PF que aprenderás en la próxima sección.

Hay cuatro variaciones del ciclo _for_ básico:

1.  Modificar un objeto existente, en lugar de crear un nuevo objeto.
2.  Iterar sobre nombres o valores, en lugar de índices.
3.  Manejo de _outputs_ de longitud desconocida.
4.  Manejo de secuencias de longitud desconocida.

### Modificar un objeto existente

Algunas veces quiere usar un bucle for para modificar un objeto existente. Por ejemplo, recuerda nuestro desafío de [funciones]. Queríamos reescalar cada columna en un _data frame_:

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

Para resolver esto con un bucle _for_, volvemos a pensar en los tres componentes:

1.  __Output__: ya tenemos el _output_ --- ¡es lo mismo que la entrada!

2.  __Secuencia__: podemos pensar en un _data frame_ como una lista de columnas, por lo
     que podemos iterar sobre cada columna con `seq_along (df)`.

3.  __Cuerpo__: aplicar `rescale01 ()`.

Esto nos da:

```{r}
for (i in seq_along(df)) {
  df[[i]] <- rescale01(df[[i]])
}
```

Por lo general, se modificará una lista o un _data frame_ con este tipo de bucle, así que recuerde usar `[[`, not `[`. Podrás haber visto que usamos `[[` en todos los bucles _for_: creemos que es mejor usar `[[` incluso para vectores atómicos porque deja en claro que queremos trabajar con un solo elemento.

### Patrones de bucle

Hay tres formas básicas de hacer un bucle sobre un vector. Hasta ahora hemos visto la más general: iterar sobre los índices numéricos con `for (i in seq_along (xs))`, y extraer el valor con `x [[i]]`. Hay otras dos formas:

1.  Iterar sobre los elementos: `for (x in xs)`. Esta forma es la más útil si solo
    te preocupas por los efectos secundario, como graficar o grabar un archivo, porque es 
    dificil almacenar la salida (_output_) de forma eficiente.

2.  Iterar sobre los nombres: `for (nm in names(xs))`. te da el nombre, que se puede usar para acceder al valor con `x [[nm]]`. 
	Esto es útil si queremos utilizar el nombre en el título de un gráfico o 
    en el nombre de un archivo. Si estas creando una salida con nombre, asegúrate de nombrar el vector de resultados de esta manera:
    
    ```{r, eval = FALSE}
    results <- vector("list", length(x))
    names(results) <- names(x)
    ```

3.	Iterar sobre los índices numéricos es la forma más general, porque dada la posición se puede extraer tanto el nombre como el valor:

```{r, eval = FALSE}
for (i in seq_along(x)) {
  name <- names(x)[[i]]
  value <- x[[i]]
}
```

### Longitud de _output_ desconocida

Sometimes you might not know how long the output will be. For example, imagine you want to simulate some random vectors of random lengths. You might be tempted to solve this problem by progressively growing the vector:
Es posible que algunas veces no sepas el tamaño que tendrá el _output_. Por ejemplo, imagina que quieres simular algunos vectores aleatorios de longitudes aleatorias. Podrías tentarte a resolver este problema haciendo crecer progresivamente el vector:

```{r}
means <- c(0, 1, 2)

output <- double()
for (i in seq_along(means)) {
  n <- sample(100, 1)
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)
```

Pero esto no es muy eficiente porque en cada iteración, R tiene que copiar todos los datos de las iteraciones anteriores. En términos técnicos, obtiene un comportamiento "cuadrático" ($O(n^2)$), lo que significa que un bucle que tiene tres veces más elementos tomaría nueve ($3^2$) veces más tiempo de ejecución.

Una mejor solución es guardar los resultados en una lista, y luego combinarlos en un solo vector después de que se complete el ciclo:

```{r}
out <- vector("list", length(means))
for (i in seq_along(means)) {
  n <- sample(100, 1)
  out[[i]] <- rnorm(n, means[[i]])
}
str(out)
str(unlist(out))
```

Aquí usamos `unlist ()` (del inglés _deslistar_) para aplanar una lista de vectores en un solo vector. Una opción más estricta es usar `purrr :: flatten_dbl ()` (del inglés _aplanar_) --- arrojará un error si la entrada no es una lista de dobles.

Este patrón ocurre también en otros lugares:

1.  Podriamos estar generando una cadena larga. En lugar de pegar (`paste ()`) juntos
    cada iteración con la anterior, guardamos el _output_ en un vector de caracteres y
    luego combinamos ese vector en una cadena con
    `paste(output, collapse = "")`.
   
2. Podríamos estar generando un _data frame_ grande. En lugar de enlazar (`rbind ()`) secuencialmente
   en cada iteración, guardamos el resultado en una lista y luego usamos
    `dplyr::bind_rows(output)` para combinar el _output_ en un solo _data frame_.

Cuidado con este patrón. Cuando lo veamos, cambiemos a un objeto de resultado más complejo y luego lo combinamos en un paso al final.

### Longitud de secuencia desconocida

A veces ni siquiera sabemos cuánto tiempo puede durar la secuencia de entrada. Esto es común cuando se hacen simulaciones. Por ejemplo, es posible que se quiera realizar un bucle hasta que se obtengan tres cabezas seguidas. No podemos hacer ese tipo de iteración con un bucle _for_. En su lugar, podemos utilizar un bucle _while_ (del inglés _mientras_). Un bucle _while_ es más simple que el bucle _for_ porque solo tiene dos componentes, una condición y un cuerpo:

```{r, eval = FALSE}
while (condición) {
  # cuerpo
}
```

Un bucle _while_ también es más general que un bucle _for_, porque podemos reescribir cualquier bucle _for_ como un bucle _while_, pero no podemos reescribir cada bucle _while_ como un bucle _for_:

```{r, eval = FALSE}
for (i in seq_along(x)) {
  # cuerpo
}

# Equivalente a 
i <- 1
while (i <= length(x)) {
  # cuerpo
  i <- i + 1 
}
```

Here's how we could use a while loop to find how many tries it takes to get three heads in a row:

```{r}
flip <- function() sample(c("T", "H"), 1)

flips <- 0
nheads <- 0

while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips
```

I mention while loops only briefly, because I hardly ever use them. They're most often used for simulation, which is outside the scope of this book. However, it is good to know they exist so that you're prepared for problems where the number of iterations is not known in advance.

### Exercises

1.  Imagine you have a directory full of CSV files that you want to read in.
    You have their paths in a vector, 
    `files <- dir("data/", pattern = "\\.csv$", full.names = TRUE)`, and now
    want to read each one with `read_csv()`. Write the for loop that will 
    load them into a single data frame. 

1.  What happens if you use `for (nm in names(x))` and `x` has no names?
    What if only some of the elements are named? What if the names are
    not unique?

1.  Write a function that prints the mean of each numeric column in a data 
    frame, along with its name. For example, `show_mean(iris)` would print:
    
    ```{r, eval = FALSE}
    show_mean(iris)
    #> Sepal.Length: 5.84
    #> Sepal.Width:  3.06
    #> Petal.Length: 3.76
    #> Petal.Width:  1.20
    ```
    
    (Extra challenge: what function did I use to make sure that the numbers
    lined up nicely, even though the variable names had different lengths?)

1.  What does this code do? How does it work?

    ```{r, eval = FALSE}
    trans <- list( 
      disp = function(x) x * 0.0163871,
      am = function(x) {
        factor(x, labels = c("auto", "manual"))
      }
    )
    for (var in names(trans)) {
      mtcars[[var]] <- trans[[var]](mtcars[[var]])
    }
    ```

## For loops vs. functionals

For loops are not as important in R as they are in other languages because R is a functional programming language. This means that it's possible to wrap up for loops in a function, and call that function instead of using the for loop directly.

To see why this is important, consider (again) this simple data frame:

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

Imagine you want to compute the mean of every column. You could do that with a for loop:

```{r}
output <- vector("double", length(df))
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]])
}
output
```

You realise that you're going to want to compute the means of every column pretty frequently, so you extract it out into a function:

```{r}
col_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  output
}
```

But then you think it'd also be helpful to be able to compute the median, and the standard deviation, so you copy and paste your `col_mean()` function and replace the `mean()` with `median()` and `sd()`:

```{r}
col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}
col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}
```

Uh oh! You've copied-and-pasted this code twice, so it's time to think about how to generalise it. Notice that most of this code is for-loop boilerplate and it's hard to see the one thing (`mean()`, `median()`, `sd()`) that is different between the functions.

What would you do if you saw a set of functions like this:

```{r}
f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3
```

Hopefully, you'd notice that there's a lot of duplication, and extract it out into an additional argument:

```{r}
f <- function(x, i) abs(x - mean(x)) ^ i
```

You've reduced the chance of bugs (because you now have 1/3 less code), and made it easy to generalise to new situations. 

We can do exactly the same thing with `col_mean()`, `col_median()` and `col_sd()` by adding an argument that supplies the function to apply to each column:

```{r}
col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}
col_summary(df, median)
col_summary(df, mean)
```

The idea of passing a function to another function is extremely powerful idea, and it's one of the behaviours that makes R a functional programming language. It might take you a while to wrap your head around the idea, but it's worth the investment. In the rest of the chapter, you'll learn about and use the __purrr__ package, which provides functions that eliminate the need for many common for loops. The apply family of functions in base R (`apply()`, `lapply()`, `tapply()`, etc) solve a similar problem, but purrr is more consistent and thus is easier to learn.

The goal of using purrr functions instead of for loops is to allow you break common list manipulation challenges into independent pieces: 

1. How can you solve the problem for a single element of the list? Once
   you've solved that problem, purrr takes care of generalising your
   solution to every element in the list.

1. If you're solving a complex problem, how can you break it down into
   bite-sized pieces that allow you to advance one small step towards a 
   solution? With purrr, you get lots of small pieces that you can
   compose together with the pipe.

This structure makes it easier to solve new problems. It also makes it easier to understand your solutions to old problems when you re-read your old code.

### Exercises

1.  Read the documentation for `apply()`. In the 2d case, what two for loops
    does it generalise?

1.  Adapt `col_summary()` so that it only applies to numeric columns
    You might want to start with an `is_numeric()` function that returns
    a logical vector that has a TRUE corresponding to each numeric column.

## The map functions

The pattern of looping over a vector, doing something to each element and saving the results is so common that the purrr package provides a family of functions to do it for you. There is one function for each type of output:

* `map()`     makes a list.
* `map_lgl()` makes a logical vector.
* `map_int()` makes an integer vector.
* `map_dbl()` makes a double vector.
* `map_chr()` makes a character vector.

Each function takes a vector as input, applies a function to each piece, and then returns a new vector that's the same length (and has the same names) as the input. The type of the vector is determined by the suffix to the map function. 

Once you master these functions, you'll find it takes much less time to solve iteration problems. But you should never feel bad about using a for loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. The important thing is that you solve the problem that you're working on, not write the most concise and elegant code (although that's definitely something you want to strive towards!).

Some people will tell you to avoid for loops because they are slow. They're wrong! (Well at least they're rather out of date, as for loops haven't been slow for many years). The chief benefits of using functions like `map()` is not speed, but clarity: they make your code easier to write and to read.

We can use these functions to perform the same computations as the last for loop. Those summary functions returned doubles, so we need to use `map_dbl()`:

```{r}
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
```

Compared to using a for loop, focus is on the operation being performed (i.e. `mean()`, `median()`, `sd()`), not the bookkeeping required to loop over every element and store the output. This is even more apparent if we use the pipe:

```{r}
df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)
```

There are a few differences between `map_*()` and `col_summary()`:

*   All purrr functions are implemented in C. This makes them a little faster
    at the expense of readability.
    
*   The second argument, `.f`, the function to apply, can be a formula, a 
    character vector, or an integer vector. You'll learn about those handy 
    shortcuts in the next section.
    
*   `map_*()` uses ... ([dot dot dot]) to pass along additional arguments 
    to `.f` each time it's called:

    ```{r}
    map_dbl(df, mean, trim = 0.5)
    ```

*   The map functions also preserve names:

    ```{r}
    z <- list(x = 1:3, y = 4:5)
    map_int(z, length)
    ```

### Shortcuts

There are a few shortcuts that you can use with `.f` in order to save a little typing. Imagine you want to fit a linear model to each group in a dataset. The following toy example splits the up the `mtcars` dataset in to three pieces (one for each value of cylinder) and fits the same linear model to each piece:  

```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))
```

The syntax for creating an anonymous function in R is quite verbose so purrr provides a convenient shortcut: a one-sided formula.

```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))
```

Here I've used `.` as a pronoun: it refers to the current list element (in the same way that `i` referred to the current index in the for loop). 

When you're looking at many models, you might want to extract a summary statistic like the $R^2$. To do that we need to first run `summary()` and then extract the component called `r.squared`. We could do that using the shorthand for anonymous functions:

```{r}
models %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared)
```

But extracting named components is a common operation, so purrr provides an even shorter shortcut: you can use a string.

```{r}
models %>% 
  map(summary) %>% 
  map_dbl("r.squared")
```

You can also use an integer to select elements by position: 

```{r}
x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)
```

### Base R
  
If you're familiar with the apply family of functions in base R, you might have noticed some similarities with the purrr functions:

*   `lapply()` is basically identical to `map()`, except that `map()` is 
    consistent with all the other functions in purrr, and you can use the 
    shortcuts for `.f`.

*   Base `sapply()` is a wrapper around `lapply()` that automatically
    simplifies the output. This is useful for interactive work but is 
    problematic in a function because you never know what sort of output
    you'll get:
    
    ```{r}
    x1 <- list(
      c(0.27, 0.37, 0.57, 0.91, 0.20),
      c(0.90, 0.94, 0.66, 0.63, 0.06), 
      c(0.21, 0.18, 0.69, 0.38, 0.77)
    )
    x2 <- list(
      c(0.50, 0.72, 0.99, 0.38, 0.78), 
      c(0.93, 0.21, 0.65, 0.13, 0.27), 
      c(0.39, 0.01, 0.38, 0.87, 0.34)
    )
    
    threshold <- function(x, cutoff = 0.8) x[x > cutoff]
    x1 %>% sapply(threshold) %>% str()
    x2 %>% sapply(threshold) %>% str()
    ```

*   `vapply()` is a safe alternative to `sapply()` because you supply an
    additional argument that defines the type. The only problem with 
    `vapply()` is that it's a lot of typing: 
    `vapply(df, is.numeric, logical(1))` is equivalent to
    `map_lgl(df, is.numeric)`. One advantage of `vapply()` over purrr's map
    functions is that it can also produce matrices --- the map functions only 
    ever produce vectors.

I focus on purrr functions here because they have more consistent names and arguments, helpful shortcuts, and in the future will provide easy parallelism and progress bars.

### Exercises

1.  Write code that uses one of the map functions to:

    1. Compute the mean of every column in `mtcars`.
    1. Determine the type of each column in `nycflights13::flights`.
    1. Compute the number of unique values in each column of `iris`.
    1. Generate 10 random normals for each of $\mu = -10$, $0$, $10$, and $100$.

1.  How can you create a single vector that for each column in a data frame
    indicates whether or not it's a factor?

1.  What happens when you use the map functions on vectors that aren't lists?
    What does `map(1:5, runif)` do? Why?
    
1.  What does `map(-2:2, rnorm, n = 5)` do? Why?
    What does `map_dbl(-2:2, rnorm, n = 5)` do? Why?

1.  Rewrite `map(x, function(df) lm(mpg ~ wt, data = df))` to eliminate the 
    anonymous function. 

## Dealing with failure

When you use the map functions to repeat many operations, the chances are much higher that one of those operations will fail. When this happens, you'll get an error message, and no output. This is annoying: why does one failure prevent you from accessing all the other successes? How do you ensure that one bad apple doesn't ruin the whole barrel?

In this section you'll learn how to deal this situation with a new function: `safely()`. `safely()` is an adverb: it takes a function (a verb) and returns a modified version. In this case, the modified function will never throw an error. Instead, it always returns a list with two elements:

1. `result` is the original result. If there was an error, this will be `NULL`.

1. `error` is an error object. If the operation was successful, this will be 
   `NULL`.

(You might be familiar with the `try()` function in base R. It's similar, but because it sometimes returns the original result and it sometimes returns an error object it's more difficult to work with.)

Let's illustrate this with a simple example: `log()`:

```{r}
safe_log <- safely(log)
str(safe_log(10))
str(safe_log("a"))
```

When the function succeeds, the `result` element contains the result and the `error` element is `NULL`. When the function fails, the `result` element is `NULL` and the `error` element contains an error object.

`safely()` is designed to work with map:

```{r}
x <- list(1, 10, "a")
y <- x %>% map(safely(log))
str(y)
```

This would be easier to work with if we had two lists: one of all the errors and one of all the output. That's easy to get with `purrr::transpose()`:

```{r}
y <- y %>% transpose()
str(y)
```

It's up to you how to deal with the errors, but typically you'll either look at the values of `x` where `y` is an error, or work with the values of `y` that are ok:

```{r}
is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]
y$result[is_ok] %>% flatten_dbl()
```

Purrr provides two other useful adverbs:

*   Like `safely()`, `possibly()` always succeeds. It's simpler than `safely()`, 
    because you give it a default value to return when there is an error. 
    
    ```{r}
    x <- list(1, 10, "a")
    x %>% map_dbl(possibly(log, NA_real_))
    ```
    
*   `quietly()` performs a similar role to `safely()`, but instead of capturing
    errors, it captures printed output, messages, and warnings:
    
    ```{r}
    x <- list(1, -1)
    x %>% map(quietly(log)) %>% str()
    ```

## Mapping over multiple arguments

So far we've mapped along a single input. But often you have multiple related inputs that you need iterate along in parallel. That's the job of the `map2()` and `pmap()` functions. For example, imagine you want to simulate some random normals with different means. You know how to do that with `map()`:

```{r}
mu <- list(5, 10, -3)
mu %>% 
  map(rnorm, n = 5) %>% 
  str()
```

What if you also want to vary the standard deviation? One way to do that would be to iterate over the indices and index into vectors of means and sds:

```{r}
sigma <- list(1, 5, 10)
seq_along(mu) %>% 
  map(~rnorm(5, mu[[.]], sigma[[.]])) %>% 
  str()
```

But that obfuscates the intent of the code. Instead we could use `map2()` which iterates over two vectors in parallel:

```{r}
map2(mu, sigma, rnorm, n = 5) %>% str()
```

`map2()` generates this series of function calls:

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-map2.png")
```

Note that the arguments that vary for each call come _before_ the function; arguments that are the same for every call come _after_.

Like `map()`, `map2()` is just a wrapper around a for loop:

```{r}
map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}
```

You could also imagine `map3()`, `map4()`, `map5()`, `map6()` etc, but that would get tedious quickly. Instead, purrr provides `pmap()` which takes a list of arguments. You might use that if you wanted to vary the mean, standard deviation, and number of samples:

```{r}
n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>%
  pmap(rnorm) %>% 
  str()
```

That looks like:

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-pmap-unnamed.png")
```

If you don't name the elements of list, `pmap()` will use positional matching when calling the function. That's a little fragile, and makes the code harder to read, so it's better to name the arguments:

```{r, eval = FALSE}
args2 <- list(mean = mu, sd = sigma, n = n)
args2 %>% 
  pmap(rnorm) %>% 
  str()
```

That generates longer, but safer, calls:

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-pmap-named.png")
```

Since the arguments are all the same length, it makes sense to store them in a data frame:

```{r}
params <- tribble(
  ~mean, ~sd, ~n,
    5,     1,  1,
   10,     5,  3,
   -3,    10,  5
)
params %>% 
  pmap(rnorm)
```

As soon as your code gets complicated, I think a data frame is a good approach because it ensures that each column has a name and is the same length as all the other columns.

### Invoking different functions

There's one more step up in complexity - as well as varying the arguments to the function you might also vary the function itself:

```{r}
f <- c("runif", "rnorm", "rpois")
param <- list(
  list(min = -1, max = 1), 
  list(sd = 5), 
  list(lambda = 10)
)
```

To handle this case, you can use `invoke_map()`:

```{r}
invoke_map(f, param, n = 5) %>% str()
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/lists-invoke.png")
```

The first argument is a list of functions or character vector of function names. The second argument is a list of lists giving the arguments that vary for each function. The subsequent arguments are passed on to every function.

And again, you can use `tribble()` to make creating these matching pairs a little easier:

```{r, eval = FALSE}
sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)
sim %>% 
  mutate(sim = invoke_map(f, params, n = 10))
```

## Walk {#walk}

Walk is an alternative to map that you use when you want to call a function for its side effects, rather than for its return value. You typically do this because you want to render output to the screen or save files to disk - the important thing is the action, not the return value. Here's a very simple example:

```{r}
x <- list(1, "a", 3)

x %>% 
  walk(print)
```

`walk()` is generally not that useful compared to `walk2()` or `pwalk()`. For example, if you had a list of plots and a vector of file names, you could use `pwalk()` to save each file to the corresponding location on disk:

```{r, eval = FALSE}
library(ggplot2)
plots <- mtcars %>% 
  split(.$cyl) %>% 
  map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf")

pwalk(list(paths, plots), ggsave, path = tempdir())
```

`walk()`, `walk2()` and `pwalk()` all invisibly return `.x`, the first argument. This makes them suitable for use in the middle of pipelines. 

## Other patterns of for loops

Purrr provides a number of other functions that abstract over other types of for loops. You'll use them less frequently than the map functions, but they're useful to know about. The goal here is to briefly illustrate each function, so hopefully it will come to mind if you see a similar problem in the future. Then you can go look up the documentation for more details.

### Predicate functions

A number of functions work with __predicate__ functions that return either a single `TRUE` or `FALSE`.

`keep()` and `discard()` keep elements of the input where the predicate is `TRUE` or `FALSE` respectively:

```{r}
iris %>% 
  keep(is.factor) %>% 
  str()

iris %>% 
  discard(is.factor) %>% 
  str()
```

`some()` and `every()` determine if the predicate is true for any or for all of
the elements.

```{r}
x <- list(1:5, letters, list(10))

x %>% 
  some(is_character)

x %>% 
  every(is_vector)
```

`detect()` finds the first element where the predicate is true; `detect_index()` returns its position.

```{r}
x <- sample(10)
x

x %>% 
  detect(~ . > 5)

x %>% 
  detect_index(~ . > 5)
```

`head_while()` and `tail_while()` take elements from the start or end of a vector while a predicate is true:

```{r}
x %>% 
  head_while(~ . > 5)

x %>% 
  tail_while(~ . > 5)
```

### Reduce and accumulate

Sometimes you have a complex list that you want to reduce to a simple list by repeatedly applying a function that reduces a pair to a singleton. This is useful if you want to apply a two-table dplyr verb to multiple tables. For example, you might have a list of data frames, and you want to reduce to a single data frame by joining the elements together:

```{r}
dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),
  trt = tibble(name = "Mary", treatment = "A")
)

dfs %>% reduce(full_join)
```

Or maybe you have a list of vectors, and want to find the intersection:

```{r}
vs <- list(
  c(1, 3, 5, 6, 10),
  c(1, 2, 3, 7, 8, 10),
  c(1, 2, 3, 4, 8, 9, 10)
)

vs %>% reduce(intersect)
```

The reduce function takes a "binary" function (i.e. a function with two primary inputs), and applies it repeatedly to a list until there is only a single element left.

Accumulate is similar but it keeps all the interim results. You could use it to implement a cumulative sum:

```{r}
x <- sample(10)
x
x %>% accumulate(`+`)
```

### Exercises

1.  Implement your own version of `every()` using a for loop. Compare it with
    `purrr::every()`. What does purrr's version do that your version doesn't?

1.  Create an enhanced `col_sum()` that applies a summary function to every
    numeric column in a data frame.

1.  A possible base R equivalent of `col_sum()` is:

    ```{r}
    col_sum3 <- function(df, f) {
      is_num <- sapply(df, is.numeric)
      df_num <- df[, is_num]

      sapply(df_num, f)
    }
    ```
    
    But it has a number of bugs as illustrated with the following inputs:
    
    ```{r, eval = FALSE}
    df <- tibble(
      x = 1:3, 
      y = 3:1,
      z = c("a", "b", "c")
    )
    # OK
    col_sum3(df, mean)
    # Has problems: don't always return numeric vector
    col_sum3(df[1:2], mean)
    col_sum3(df[1], mean)
    col_sum3(df[0], mean)
    ```
    
    What causes the bugs?
